## 审查结论（按你给的 4 个重点区域）
### 1) RNA_cluster_data 数据处理模块
- **预处理输出与 Dataset 预期字段基本一致，但缺关键 mask 语义**：`preprocess_ensemble.py` 写出的 `complex_feats` 包含 `aatype/atom_positions/atom_mask/...`（见 [preprocess_ensemble.py](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/preprocess_ensemble.py#L46-L272)），`RNAClusterDataset.__getitem__` 读取并重算 frames/torsions（见 [rna_cluster_dataset.py](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L113-L261)）。但 dataset 目前把 `res_mask` 直接设成全 1（[rna_cluster_dataset.py:L237-L247](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L237-L247)），会把缺失残基/无效原子也当有效，导致损失与 RMSD/指标不可信。
- **split 逻辑重复执行**：`RNAClusterDataset.__init__` 里同一段 split 代码出现两次（[rna_cluster_dataset.py:L46-L109](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L46-L109)），属于明显 bug/冗余。
- **缺少数据清洗/标准化的“可控入口”**：预处理没有显式做坐标标准化（中心化/尺度）、缺失残基清洗策略依赖 `parsers/utils` 内部实现，外部不可见；建议把“有效残基 mask / 过滤规则”作为明确产物写入并在 Dataset 中使用。
- **潜在死循环**：当 cluster 内没有 `features/*.pkl` 或没有 embedding 时，`__getitem__` 递归调用自身（[rna_cluster_dataset.py:L116-L125](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L116-L125)、[rna_cluster_dataset.py:L180-L182](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L180-L182)），若整个数据都缺 embedding/feature，会无限递归。

### 2) 模型核心逻辑（conditional）
- **conditional 信息=embedding（而不是序列 token）**：`FlowModel.forward` 只读取 `single_embedding/pair_embedding`（[flow_model.py:L126-L153](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/flow_model.py#L126-L153)），并分别进入 [NodeEmbedder](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/node_embedder.py#L37-L57) 与 [EdgeEmbedder](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/edge_embedder.py#L57-L78)。当前 `aatype` 仅在保存 PDB 时可能用到，不参与条件控制。
- **训练输入键名不匹配（致命）**：Dataset/DataModule 产出的是 `single_embeds/pair_embeds`（[rna_cluster_dataset.py:L248-L260](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L248-L260)；collate 也按这个键 pad），但 FlowModel 读的是 `single_embedding/pair_embedding`（[flow_model.py:L136-L137](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/flow_model.py#L136-L137)）。训练路径里 `Interpolant.corrupt_batch` 不会改名（[interpolant.py:L118-L149](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/interpolant.py#L118-L149)），因此训练会 KeyError。
- **基础数值工具函数有参数名错误（致命）**：`models/utils.py` 中 `torch.cat(..., axis=...)`、`torch.linalg.norm(..., axis=...)` 使用了 NumPy 风格参数名（见 [models/utils.py:L12-L22](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/utils.py#L12-L22)、[models/utils.py:L40-L42](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/utils.py#L40-L42)），在 PyTorch 会报 `TypeError`（应为 `dim=`）。这会影响 distogram/位置编码等关键特征计算。

### 3) 推理和验证代码
- **inference 配置键使用错误（致命）**：训练用的是 `cfg.data_cfg`（[train_se3_flows.py:L28-L35](file:///Users/wanlima/Projects/ensemble/rna_frameflow/train_se3_flows.py#L28-L35)），但 inference 脚本里写了 `cfg.data`（[inference_se3_flows.py:L82-L86](file:///Users/wanlima/Projects/ensemble/rna_frameflow/inference_se3_flows.py#L82-L86)）。而 `configs/inference.yaml` 是 `defaults: - config`，所以数据配置仍在 `data_cfg`（[inference.yaml:L1-L5](file:///Users/wanlima/Projects/ensemble/rna_frameflow/configs/inference.yaml#L1-L5)）。推理很可能直接崩。
- **predict_step 与 dataloader 输出不匹配（致命）**：`FlowModule.predict_step` 期望 batch 有 `num_res/sample_id`（[flow_module.py:L495-L503](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/flow_module.py#L495-L503)），但 `RNAClusterDataset` 返回的是 `trans_1/rotmats_1/...`（[rna_cluster_dataset.py:L248-L260](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/data/rna_cluster_dataset.py#L248-L260)），不含这些字段。
- **predict_step 内存在明显拷贝粘贴错误（致命）**：同一段保存逻辑重复 3-4 次，并引用未定义变量 `pdb_name`（[flow_module.py:L528-L578](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/flow_module.py#L528-L578)）。
- **验证指标链路混杂**：当前 validation 里一边采样一边写 PDB/算几何指标（原逻辑），新加入的 RMSD/valid loss 若没有严格 mask 与对齐策略，会导致数值不稳定（例如 Kabsch 至少要 3 个点；mask 全 1 会把缺失残基算进去）。建议把“val loss（teacher-forcing）”与“采样质量指标（RMSD/几何约束）”分开、并显式开关。

### 4) 训练流程
- **debug 分支会报错**：`self._data_cfg.loader.num_workers = 0`（[train_se3_flows.py:L39-L44](file:///Users/wanlima/Projects/ensemble/rna_frameflow/train_se3_flows.py#L39-L44)），但配置里是 `data_cfg.num_workers`（[config.yaml:L1-L6](file:///Users/wanlima/Projects/ensemble/rna_frameflow/configs/config.yaml#L1-L6)），没有 `loader` 字段。
- **DDP + use_distributed_sampler=False 风险**：如果用多卡，禁用 distributed sampler 可能导致各 rank 看到同一批数据、有效 batch size 变大且统计不正确。
- **training_step 签名不规范**：写成 `(batch, stage)`（[flow_module.py:L430-L478](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/flow_module.py#L430-L478)），Lightning 实际传的是 `batch_idx`；虽然“凑巧能跑”，但不利于维护。

## 修复建议（最小闭环：先让训练/推理能正确跑）
1) **统一 batch schema（强烈建议先做）**
- 约定训练/推理共同的必需键：
  - `res_mask, trans_1, rotmats_1, torsion_angles_sin_cos, torsion_angles_mask, is_na_residue_mask`
  - conditional：统一用 `single_embedding, pair_embedding`（与 [flow_model.py](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/flow_model.py#L126-L153) 一致）
  - 推理所需：若仍走 `predict_step`，补 `sample_id/num_res`；或改 `predict_step` 直接从 batch 推断长度。

2) **修复 RNAClusterDataset/DataModule 的关键问题**
- 去掉重复 split 逻辑；把 `res_mask` 改为基于 `bb_mask`/`aatype != missing` 的真实 mask。
- 把 `single_embeds/pair_embeds` 改名为 `single_embedding/pair_embedding`（或在 collate/FlowModule 中统一映射，但建议源头统一）。
- collate 增加对 `aatype` 的 padding/stack（当前不会 pad）。
- 对“缺 embedding/feature”的样本改为抛错或跳过（避免递归死循环）。

3) **修复模型数值工具（立即）**
- 将 [models/utils.py](file:///Users/wanlima/Projects/ensemble/rna_frameflow/rna_backbone_design/models/utils.py#L12-L42) 中所有 `axis=` 改为 `dim=`，确保 `calc_distogram/get_index_embedding` 可用。

4) **修复推理链路**
- inference 脚本将 `RNAClusterDataModule(self._cfg.data)` 改为 `... (self._cfg.data_cfg)`。
- 明确推理模式：
  - A) “按 test split 的 embedding 逐条生成”：让 `predict_step` 接受 dataset 输出（用 `res_mask` 推长度、用 batch 自带 embedding）；
  - B) “按长度采样”：使用单独 LengthDataset（当前代码已注释掉原型）。
- 清理 `predict_step` 的重复与未定义变量问题。

5) **验证与指标**
- validation 里拆分两类：
  - `valid/loss`：用 `corrupt_batch + model_step` 计算（teacher-forcing 验证）。
  - `valid/rmsd_*`：对齐后 RMSD（建议先做 C4' 或 frame 原子 RMSD），并严格使用 `res_mask`（且保证有效点数>=3）。

6) **训练稳健性**
- debug 分支改成 `self._data_cfg.num_workers = 0`。
- 多卡时启用 distributed sampler（或在 DataLoader 使用 `DistributedSampler`）。

## 我接下来会怎么做（需要你确认后才会动代码）
- 第一步：把“训练能跑”作为最小闭环（修 schema、修 axis/dim、修 dataset mask/键名）。
- 第二步：把“推理能跑”作为第二闭环（修 inference 脚本与 predict_step）。
- 第三步：补最小自检脚本/pytest（只做 CPU、小 batch），确保 forward/train_step/predict_step 关键路径不再崩。

如果你确认，我会按上述顺序逐个提交修改，并在每一步给出可运行的最小复现实例与对应的验证命令。